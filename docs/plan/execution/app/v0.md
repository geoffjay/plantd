# App Service Implementation Execution Plan v0

## Overview

This document outlines the detailed execution plan for implementing the plantd App Service as a modern web-based management interface. The App Service will provide a comprehensive dashboard for monitoring, configuring, and managing all plantd distributed control system services through an intuitive web interface.

**ðŸ“Š CURRENT STATUS**: ðŸŸ¡ **PARTIAL IMPLEMENTATION** - Foundation requires complete rebuild

**ðŸŽ¯ OBJECTIVE**: Transform the App Service into a production-ready web application with comprehensive service management capabilities

## Current Status Summary

**ðŸŽ¯ OBJECTIVE**: Create a modern, secure web application for plantd system management

### Current App Service Assessment:
- **HTTP Framework**: âœ… Gin HTTP server framework established
- **Project Structure**: âœ… MVC pattern with handlers, models, views structure  
- **Static Assets**: âœ… Tailwind CSS integration and static file serving
- **Documentation**: âœ… Swagger API documentation generation
- **Configuration**: âœ… Configuration management system in place

### Critical Implementation Gaps:
- **Authentication**: ðŸ”´ Incomplete - has stub auth but not integrated with Identity Service
- **User Management**: ðŸ”´ Invalid - maintains local user models (must be removed)
- **API Endpoints**: ðŸ”´ Empty - no functional API implementations
- **Frontend UI**: ðŸ”´ Missing - no user interface components 
- **Service Integration**: ðŸ”´ None - no connection to plantd services
- **Templ Integration**: ðŸ”´ Missing - not using templ for UI components

### Required Technology Stack:
- **Backend**: Go with Gin framework (existing)
- **Authentication**: Identity Service integration (required)
- **UI Components**: Templ for server-side rendering (required)
- **Styling**: Tailwind CSS (existing, needs enhancement)
- **Build Tools**: bun for asset management (required)
- **Service Communication**: MDP protocol via broker (required)

## Timeline and Milestones

- **Phase 1**: Foundation Cleanup and Setup (1-2 weeks)
- **Phase 2**: Authentication Integration (2-3 weeks)
- **Phase 3**: Service Integration and API Development (3-4 weeks)
- **Phase 4**: Frontend UI Implementation (4-5 weeks)
- **Phase 5**: Testing and Production Readiness (2-3 weeks)
- **Phase 6**: Extended Administrative Features (1-2 weeks) [Optional Enhancement]
- **Total Estimated Duration**: 12-17 weeks (14-19 weeks with Phase 6)

## Phase 1: Foundation Cleanup and Setup (1-2 weeks)

### 1.1 Remove Invalid User Management
**Priority**: Critical
**Estimated Time**: 1-2 days

#### Tasks:
- [ ] Remove `app/models/user.go` - App Service must not maintain user models
- [ ] Remove `app/repository/user.go` - No local user database allowed
- [ ] Update `app/handlers/auth.go` to remove local authentication logic
- [ ] Clean up any references to local user management in handlers
- [ ] Remove user-related imports and dependencies

#### Rationale:
The App Service must rely exclusively on the Identity Service for user management. Maintaining local user models violates the distributed architecture and creates security vulnerabilities.

#### Acceptance Criteria:
- [ ] No local user models or repositories exist
- [ ] No local authentication logic remains
- [ ] Service compiles without user-related dependencies
- [ ] All user management flows redirect to Identity Service

### 1.2 Templ Integration Setup
**Priority**: Critical
**Estimated Time**: 2-3 days

#### Tasks:
- [ ] Add templ dependency to `go.mod`
- [ ] Install templ CLI tool for code generation
- [ ] Convert existing view templates from standard Go templates to templ
- [ ] Create templ component structure:
  ```
  app/views/
  â”œâ”€â”€ components/
  â”‚   â”œâ”€â”€ header.templ
  â”‚   â”œâ”€â”€ sidebar.templ
  â”‚   â”œâ”€â”€ navigation.templ
  â”‚   â””â”€â”€ layout/
  â”‚       â”œâ”€â”€ base.templ
  â”‚       â””â”€â”€ dashboard.templ
  â”œâ”€â”€ pages/
  â”‚   â”œâ”€â”€ dashboard.templ
  â”‚   â”œâ”€â”€ services.templ
  â”‚   â”œâ”€â”€ health.templ
  â”‚   â”œâ”€â”€ config.templ
  â”‚   â””â”€â”€ metrics.templ
  â””â”€â”€ partials/
      â”œâ”€â”€ service_card.templ
      â”œâ”€â”€ health_status.templ
      â””â”€â”€ metric_chart.templ
  ```
- [ ] Set up templ generation in build process
- [ ] Update handlers to use templ components
- [ ] Create base layout with responsive design

#### Templ Dependencies:
```go
// go.mod additions
github.com/a-h/templ v0.2.543
```

#### Build Integration:
```json
// package.json (for bun)
{
  "scripts": {
    "templ:generate": "templ generate",
    "templ:watch": "templ generate --watch",
    "build": "templ generate && bun run build-css"
  }
}
```

#### Acceptance Criteria:
- [ ] Templ is properly installed and configured
- [ ] All view templates converted to templ format
- [ ] Templ generation integrated into build process
- [ ] Base layout provides responsive foundation
- [ ] Hot reload works with templ during development

### 1.3 Bun Asset Management Setup
**Priority**: High
**Estimated Time**: 2-3 days

#### Tasks:
- [ ] Replace any npm/yarn/deno usage with bun (ensure compliance)
- [ ] Upgrade Tailwind CSS from v3 to v4 with new configuration format
- [ ] Create comprehensive `package.json` for bun:
  ```json
  {
    "name": "plantd-app",
    "scripts": {
      "dev": "bun run templ:watch & bun run watch-css",
      "build": "bun run templ:generate && bun run build-css",
      "watch-css": "tailwindcss -i public/css/input.css -o public/css/tailwind.css --watch",
      "build-css": "tailwindcss -i public/css/input.css -o public/css/tailwind.css --minify",
      "lint:css": "stylelint public/css/**/*.css",
      "format:css": "prettier --write public/css/**/*.css"
    },
    "devDependencies": {
      "tailwindcss": "^4.0.0",
      "@tailwindcss/vite": "^4.0.0",
      "@tailwindcss/forms": "^0.6.0",
      "@tailwindcss/typography": "^0.6.0",
      "autoprefixer": "^10.4.16",
      "postcss": "^8.4.32"
    }
  }
  ```
- [ ] Upgrade Tailwind CSS to v4 with new configuration:
  ```js
  // tailwind.config.js (v4 format)
  import { defineConfig } from '@tailwindcss/vite'
  
  export default defineConfig({
    content: [
      "./views/**/*.templ",
      "./views/**/*.go", 
      "./public/**/*.html"
    ],
    theme: {
      extend: {
        colors: {
          plantd: {
            primary: '#10B981',
            secondary: '#06B6D4', 
            accent: '#8B5CF6',
            danger: '#EF4444',
            warning: '#F59E0B',
            success: '#10B981'
          }
        }
      }
    }
  })
  ```
- [ ] Update build scripts for Tailwind CSS v4 compatibility:
  ```json
  // Updated package.json scripts for v4
  {
    "scripts": {
      "dev": "bun run templ:watch & bun run watch-css",
      "build": "bun run templ:generate && bun run build-css",
      "watch-css": "tailwindcss --input public/css/input.css --output public/css/tailwind.css --watch",
      "build-css": "tailwindcss --input public/css/input.css --output public/css/tailwind.css --minify"
    }
  }
  ```
- [ ] Migrate existing Tailwind CSS classes from v3 to v4 compatibility
- [ ] Set up PostCSS configuration for optimization  
- [ ] Create asset pipeline for production builds
- [ ] Implement CSS purging for production
- [ ] Test Tailwind CSS v4 features (container queries, logical properties)

#### Acceptance Criteria:
- [ ] Bun is the exclusive package manager (no npm/yarn/deno)
- [ ] Tailwind CSS v4 is successfully installed and configured
- [ ] CSS build pipeline works in development and production with v4
- [ ] All existing Tailwind classes are compatible with v4
- [ ] New v4 features (container queries, logical properties) are available
- [ ] Asset pipeline supports hot reload during development
- [ ] Production builds are minified and optimized

### 1.4 Enhanced Configuration Management
**Priority**: Medium
**Estimated Time**: 2-3 days

#### Tasks:
- [ ] Extend configuration to support Identity Service integration:
  ```go
  // app/config/config.go additions
  type Config struct {
      // ... existing fields ...
      
      Identity struct {
          Endpoint string `yaml:"endpoint" env:"PLANTD_APP_IDENTITY_ENDPOINT"`
          Timeout  string `yaml:"timeout" env:"PLANTD_APP_IDENTITY_TIMEOUT"`
          ClientID string `yaml:"client_id" env:"PLANTD_APP_IDENTITY_CLIENT_ID"`
      } `yaml:"identity"`
      
      Services struct {
          BrokerEndpoint string `yaml:"broker_endpoint" env:"PLANTD_APP_BROKER_ENDPOINT"`
          StateEndpoint  string `yaml:"state_endpoint" env:"PLANTD_APP_STATE_ENDPOINT"`
          Timeout        string `yaml:"timeout" env:"PLANTD_APP_SERVICES_TIMEOUT"`
      } `yaml:"services"`
      
      Session struct {
          SecretKey     string `yaml:"secret_key" env:"PLANTD_APP_SESSION_SECRET"`
          CookieName    string `yaml:"cookie_name" env:"PLANTD_APP_SESSION_COOKIE"`
          MaxAge        int    `yaml:"max_age" env:"PLANTD_APP_SESSION_MAX_AGE"`
          Secure        bool   `yaml:"secure" env:"PLANTD_APP_SESSION_SECURE"`
          HttpOnly      bool   `yaml:"http_only" env:"PLANTD_APP_SESSION_HTTP_ONLY"`
      } `yaml:"session"`
      
      Features struct {
          EnableMetrics bool `yaml:"enable_metrics" env:"PLANTD_APP_ENABLE_METRICS"`
          EnableConfig  bool `yaml:"enable_config" env:"PLANTD_APP_ENABLE_CONFIG"`
          EnableHealth  bool `yaml:"enable_health" env:"PLANTD_APP_ENABLE_HEALTH"`
      } `yaml:"features"`
  }
  ```
- [ ] Add configuration validation for all new sections
- [ ] Create development and production configuration examples
- [ ] Add environment variable documentation
- [ ] Implement configuration hot-reload for development

#### Environment Variables:
- `PLANTD_APP_IDENTITY_ENDPOINT` (default: "tcp://127.0.0.1:7200")
- `PLANTD_APP_BROKER_ENDPOINT` (default: "tcp://127.0.0.1:7100") 
- `PLANTD_APP_SESSION_SECRET` (required for production)
- `PLANTD_APP_ENABLE_*` (feature flags for different modules)

#### Acceptance Criteria:
- [ ] Configuration supports all required integrations
- [ ] Environment variable overrides work for all settings
- [ ] Configuration validation prevents startup with invalid settings
- [ ] Development and production examples are provided
- [ ] Hot-reload works for configuration changes during development

### 1.5 Project Structure Reorganization
**Priority**: Medium
**Estimated Time**: 1-2 days

#### Tasks:
- [ ] Reorganize project structure for scalability:
  ```
  app/
  â”œâ”€â”€ cmd/
  â”‚   â””â”€â”€ main.go                 # Application entry point
  â”œâ”€â”€ internal/
  â”‚   â”œâ”€â”€ auth/                   # Authentication middleware
  â”‚   â”‚   â”œâ”€â”€ middleware.go
  â”‚   â”‚   â”œâ”€â”€ session.go
  â”‚   â”‚   â””â”€â”€ identity_client.go
  â”‚   â”œâ”€â”€ services/               # Service layer
  â”‚   â”‚   â”œâ”€â”€ broker_service.go
  â”‚   â”‚   â”œâ”€â”€ state_service.go
  â”‚   â”‚   â”œâ”€â”€ health_service.go
  â”‚   â”‚   â””â”€â”€ config_service.go
  â”‚   â”œâ”€â”€ handlers/               # HTTP handlers
  â”‚   â”‚   â”œâ”€â”€ auth_handler.go
  â”‚   â”‚   â”œâ”€â”€ dashboard_handler.go
  â”‚   â”‚   â”œâ”€â”€ services_handler.go
  â”‚   â”‚   â”œâ”€â”€ health_handler.go
  â”‚   â”‚   â”œâ”€â”€ config_handler.go
  â”‚   â”‚   â””â”€â”€ api/
  â”‚   â”‚       â”œâ”€â”€ services.go
  â”‚   â”‚       â”œâ”€â”€ health.go
  â”‚   â”‚       â””â”€â”€ metrics.go
  â”‚   â””â”€â”€ models/                 # Data transfer objects
  â”‚       â”œâ”€â”€ service_status.go
  â”‚       â”œâ”€â”€ health_check.go
  â”‚       â”œâ”€â”€ metrics.go
  â”‚       â””â”€â”€ responses.go
  â”œâ”€â”€ views/                      # Templ templates
  â”œâ”€â”€ static/                     # Static assets
  â”‚   â”œâ”€â”€ css/
  â”‚   â”œâ”€â”€ js/
  â”‚   â””â”€â”€ images/
  â”œâ”€â”€ config.yml                  # Configuration file
  â””â”€â”€ package.json                # Bun configuration
  ```
- [ ] Move main.go to cmd/ directory (Go best practice)
- [ ] Create internal/ directory for private packages
- [ ] Separate API handlers from web page handlers
- [ ] Create proper service layer for business logic
- [ ] Update import paths throughout the codebase

#### Acceptance Criteria:
- [ ] Project structure follows Go best practices
- [ ] Clear separation between API and web handlers
- [ ] Service layer provides clean business logic abstraction
- [ ] All imports updated to new structure
- [ ] Build and development workflows still function correctly

---

## âœ… PHASE 1 COMPLETION CRITERIA

**Status**: ðŸŸ¡ **READY FOR IMPLEMENTATION**

### Phase 1 Achievements Required:
- **Clean Foundation**: All invalid user management removed, no local user models
- **Templ Integration**: Complete templ setup with component structure and build integration
- **Bun Asset Management**: Exclusive use of bun with optimized CSS pipeline
- **Enhanced Configuration**: Support for Identity Service, services, sessions, and feature flags
- **Organized Structure**: Scalable project organization following Go best practices

### Ready for Phase 2:
All prerequisites met for Authentication Integration:
- Foundation cleaned of invalid user management
- Templ and bun properly configured and functional
- Configuration system supports Identity Service integration
- Project structure supports authentication middleware and session management
- Build system works for both development and production

---

## Phase 2: Authentication Integration (2-3 weeks)

### 2.1 Identity Service Client Integration
**Priority**: Critical
**Estimated Time**: 3-4 days

#### Tasks:
- [ ] Add Identity Service client dependency to `go.mod`
- [ ] Create Identity Service client wrapper in `internal/auth/identity_client.go`:
  ```go
  // internal/auth/identity_client.go
  type IdentityClient struct {
      client *identity.Client
      config *config.Config
  }
  
  func NewIdentityClient(cfg *config.Config) (*IdentityClient, error) {
      client, err := identity.NewClient(cfg.Identity.Endpoint, cfg.Identity.Timeout)
      if err != nil {
          return nil, fmt.Errorf("failed to create identity client: %w", err)
      }
      
      return &IdentityClient{
          client: client,
          config: cfg,
      }, nil
  }
  
  func (ic *IdentityClient) ValidateToken(token string) (*identity.UserContext, error) {
      // Validate JWT token with Identity Service
  }
  
  func (ic *IdentityClient) RefreshToken(refreshToken string) (*identity.TokenPair, error) {
      // Refresh access token using refresh token
  }
  ```
- [ ] Add connection health monitoring and retry logic
- [ ] Implement graceful degradation when Identity Service unavailable
- [ ] Add Identity Service configuration validation
- [ ] Create Identity Service integration tests

#### Dependencies:
```go
// go.mod additions
github.com/geoffjay/plantd/identity/pkg/client v0.1.0
```

#### Acceptance Criteria:
- [ ] Identity Service client connects successfully
- [ ] Token validation works correctly
- [ ] Connection failures are handled gracefully
- [ ] Health monitoring provides Identity Service status
- [ ] Integration tests verify all client operations

### 2.2 Session Management Implementation
**Priority**: Critical
**Estimated Time**: 4-5 days

#### Tasks:
- [ ] Create session management in `internal/auth/session.go`:
  ```go
  // internal/auth/session.go
  type SessionManager struct {
      store   sessions.Store
      config  *config.Config
  }
  
  type SessionData struct {
      UserID       string    `json:"user_id"`
      Email        string    `json:"email"`
      Roles        []string  `json:"roles"`
      Organizations []string `json:"organizations"`
      AccessToken  string    `json:"access_token"`
      RefreshToken string    `json:"refresh_token"`
      ExpiresAt    time.Time `json:"expires_at"`
  }
  
  func (sm *SessionManager) CreateSession(ctx *gin.Context, userData *SessionData) error {
      // Create secure session with user data
  }
  
  func (sm *SessionManager) GetSession(ctx *gin.Context) (*SessionData, error) {
      // Retrieve and validate session data
  }
  
  func (sm *SessionManager) RefreshSession(ctx *gin.Context) error {
      // Refresh session using refresh token
  }
  
  func (sm *SessionManager) DestroySession(ctx *gin.Context) error {
      // Securely destroy session
  }
  ```
- [ ] Implement secure session storage (memory/Redis)
- [ ] Add session validation and expiry handling
- [ ] Create session refresh middleware
- [ ] Implement session security features (CSRF protection, secure cookies)
- [ ] Add session cleanup and garbage collection

#### Session Security Features:
- **Secure Cookies**: HttpOnly, Secure flags, SameSite protection
- **CSRF Protection**: Token-based CSRF protection for state-changing operations
- **Session Rotation**: Regular session ID rotation for security
- **Automatic Refresh**: Transparent token refresh before expiry
- **Secure Logout**: Proper session cleanup and token invalidation

#### Acceptance Criteria:
- [ ] Sessions are created securely with proper configuration
- [ ] Session validation works correctly with token refresh
- [ ] CSRF protection prevents cross-site attacks
- [ ] Session cleanup prevents memory leaks
- [ ] All session operations are thoroughly tested

### 2.3 Authentication Middleware
**Priority**: Critical
**Estimated Time**: 3-4 days

#### Tasks:
- [ ] Create authentication middleware in `internal/auth/middleware.go`:
  ```go
  // internal/auth/middleware.go
  type AuthMiddleware struct {
      identityClient *IdentityClient
      sessionManager *SessionManager
      config         *config.Config
  }
  
  func (am *AuthMiddleware) RequireAuth() gin.HandlerFunc {
      return func(c *gin.Context) {
          session, err := am.sessionManager.GetSession(c)
          if err != nil {
              c.Redirect(http.StatusTemporaryRedirect, "/login")
              c.Abort()
              return
          }
          
          // Validate token with Identity Service
          userCtx, err := am.identityClient.ValidateToken(session.AccessToken)
          if err != nil {
              // Try to refresh token
              if refreshErr := am.sessionManager.RefreshSession(c); refreshErr != nil {
                  c.Redirect(http.StatusTemporaryRedirect, "/login")
                  c.Abort()
                  return
              }
          }
          
          // Set user context for handlers
          c.Set("user", userCtx)
          c.Next()
      }
  }
  
  func (am *AuthMiddleware) RequireRole(role string) gin.HandlerFunc {
      return func(c *gin.Context) {
          user := c.MustGet("user").(*identity.UserContext)
          if !user.HasRole(role) {
              c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
              c.Abort()
              return
          }
          c.Next()
      }
  }
  
  func (am *AuthMiddleware) RequirePermission(permission string) gin.HandlerFunc {
      return func(c *gin.Context) {
          user := c.MustGet("user").(*identity.UserContext)
          if !user.HasPermission(permission) {
              c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
              c.Abort()
              return
          }
          c.Next()
      }
  }
  ```
- [ ] Implement role-based authorization middleware
- [ ] Add permission-based authorization middleware  
- [ ] Create API-specific authentication middleware (for AJAX calls)
- [ ] Implement authentication bypass for health checks
- [ ] Add comprehensive logging for authentication events

#### Middleware Features:
- **Automatic Token Refresh**: Transparent renewal of expired tokens
- **Flexible Authorization**: Role-based and permission-based checks
- **API Support**: JSON responses for API endpoints
- **Audit Logging**: Security events and authentication attempts
- **Error Handling**: Graceful handling of authentication failures

#### Acceptance Criteria:
- [ ] Authentication middleware enforces access control correctly
- [ ] Token refresh happens transparently to users
- [ ] Role and permission checks work accurately
- [ ] API endpoints receive appropriate JSON responses
- [ ] Authentication events are properly logged

### 2.4 Login/Logout Handlers
**Priority**: High
**Estimated Time**: 4-5 days

#### Tasks:
- [ ] Create authentication handlers in `internal/handlers/auth_handler.go`:
  ```go
  // internal/handlers/auth_handler.go
  type AuthHandler struct {
      identityClient *auth.IdentityClient
      sessionManager *auth.SessionManager
      templates      *template.TemplateEngine
  }
  
  func (ah *AuthHandler) ShowLogin(c *gin.Context) {
      // Render login page using templ
      ah.templates.Render(c, "pages/login", nil)
  }
  
  func (ah *AuthHandler) HandleLogin(c *gin.Context) {
      // Process login form submission
      email := c.PostForm("email")
      password := c.PostForm("password")
      
      // Authenticate with Identity Service
      tokenPair, userInfo, err := ah.identityClient.Login(email, password)
      if err != nil {
          ah.templates.Render(c, "pages/login", gin.H{
              "error": "Invalid credentials"
          })
          return
      }
      
      // Create session
      sessionData := &auth.SessionData{
          UserID:       userInfo.ID,
          Email:        userInfo.Email,
          Roles:        userInfo.Roles,
          Organizations: userInfo.Organizations,
          AccessToken:  tokenPair.AccessToken,
          RefreshToken: tokenPair.RefreshToken,
          ExpiresAt:    tokenPair.ExpiresAt,
      }
      
      if err := ah.sessionManager.CreateSession(c, sessionData); err != nil {
          // Handle session creation error
          c.JSON(http.StatusInternalServerError, gin.H{"error": "Session creation failed"})
          return
      }
      
      c.Redirect(http.StatusSeeOther, "/dashboard")
  }
  
  func (ah *AuthHandler) HandleLogout(c *gin.Context) {
      // Process logout
      if err := ah.sessionManager.DestroySession(c); err != nil {
          log.WithError(err).Error("Failed to destroy session")
      }
      
      c.Redirect(http.StatusSeeOther, "/login")
  }
  ```
- [ ] Create login page using templ:
  ```templ
  // views/pages/login.templ
  package pages
  
  import "github.com/geoffjay/plantd/app/views/layouts"
  
  templ Login(error string) {
      @layouts.Base("Login - Plantd") {
          <div class="min-h-screen flex items-center justify-center bg-gray-50">
              <div class="max-w-md w-full space-y-8">
                  <div>
                      <h2 class="mt-6 text-center text-3xl font-extrabold text-gray-900">
                          Sign in to Plantd
                      </h2>
                  </div>
                  if error != "" {
                      <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                          { error }
                      </div>
                  }
                  <form class="mt-8 space-y-6" action="/login" method="POST">
                      <div>
                          <label for="email" class="sr-only">Email address</label>
                          <input id="email" name="email" type="email" required 
                                 class="appearance-none rounded-t-md relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                                 placeholder="Email address"/>
                      </div>
                      <div>
                          <label for="password" class="sr-only">Password</label>
                          <input id="password" name="password" type="password" required 
                                 class="appearance-none rounded-b-md relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
                                 placeholder="Password"/>
                      </div>
                      <div>
                          <button type="submit" 
                                  class="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                              Sign in
                          </button>
                      </div>
                  </form>
              </div>
          </div>
      }
  }
  ```
- [ ] Add form validation and CSRF protection
- [ ] Implement "Remember Me" functionality
- [ ] Add forgot password flow (redirects to Identity Service)
- [ ] Create comprehensive error handling and user feedback

#### Security Features:
- **CSRF Tokens**: All forms include CSRF protection
- **Input Validation**: Server-side validation of all inputs
- **Rate Limiting**: Protection against brute force attacks
- **Secure Redirects**: Validation of redirect URLs after login
- **Audit Logging**: Login attempts and security events

#### Acceptance Criteria:
- [ ] Login form renders correctly with templ
- [ ] Authentication works with Identity Service
- [ ] Sessions are created securely after successful login
- [ ] Logout properly destroys sessions and redirects
- [ ] Error handling provides appropriate user feedback
- [ ] Security features protect against common attacks

---

## âœ… PHASE 2 COMPLETION CRITERIA

**Status**: ðŸŸ¡ **READY FOR IMPLEMENTATION**

### Phase 2 Achievements Required:
- **Identity Service Integration**: Complete client integration with health monitoring
- **Session Management**: Secure session handling with automatic token refresh
- **Authentication Middleware**: Comprehensive auth and authz middleware
- **Login/Logout Flow**: Complete authentication flow with templ UI

### Ready for Phase 3:
All prerequisites met for Service Integration and API Development:
- Authentication system fully functional and tested
- Session management provides secure user context
- Middleware enforces proper access control
- Login/logout UI provides excellent user experience

---

## Phase 3: Service Integration and API Development (3-4 weeks)

### 3.1 Broker Service Integration
**Priority**: Critical
**Estimated Time**: 4-5 days

#### Tasks:
- [ ] Create Broker Service client in `internal/services/broker_service.go`:
  ```go
  // internal/services/broker_service.go
  type BrokerService struct {
      client *client.Client
      config *config.Config
  }
  
  type ServiceStatus struct {
      Name        string    `json:"name"`
      Status      string    `json:"status"` // "healthy", "unhealthy", "unknown"
      Workers     int       `json:"workers"`
      LastSeen    time.Time `json:"last_seen"`
      Version     string    `json:"version"`
      Endpoint    string    `json:"endpoint"`
      Heartbeat   int       `json:"heartbeat_ms"`
      RequestRate float64   `json:"request_rate"`
      ErrorRate   float64   `json:"error_rate"`
  }
  
  func (bs *BrokerService) GetServiceStatuses() ([]ServiceStatus, error) {
      // Query broker for all registered services
      // Parse worker information and health status
      // Return comprehensive service status data
  }
  
  func (bs *BrokerService) GetServiceDetails(serviceName string) (*ServiceStatus, error) {
      // Get detailed information for specific service
  }
  
  func (bs *BrokerService) GetBrokerHealth() (*BrokerHealth, error) {
      // Get broker-specific health and performance metrics
  }
  ```
- [ ] Implement MDP protocol communication for service discovery
- [ ] Add real-time service status monitoring
- [ ] Create service availability health checking
- [ ] Implement service performance metrics collection
- [ ] Add broker connection health monitoring with retry logic

#### Service Discovery Features:
- **Real-time Status**: Live service status from broker heartbeats
- **Performance Metrics**: Request rates, error rates, response times
- **Worker Tracking**: Number of workers per service
- **Version Information**: Service version reporting
- **Historical Data**: Service uptime and availability tracking

#### Acceptance Criteria:
- [ ] Service status information is accurate and real-time
- [ ] Broker communication is reliable with proper error handling
- [ ] Performance metrics provide operational insights
- [ ] Service discovery works for all registered services
- [ ] Connection failures are handled gracefully

### 3.2 State Service Integration
**Priority**: High
**Estimated Time**: 3-4 days

#### Tasks:
- [ ] Create State Service client in `internal/services/state_service.go`:
  ```go
  // internal/services/state_service.go
  type StateService struct {
      client *client.Client
      config *config.Config
  }
  
  type StateData struct {
      Scope       string      `json:"scope"`
      Key         string      `json:"key"`
      Value       interface{} `json:"value"`
      Type        string      `json:"type"`
      LastUpdated time.Time   `json:"last_updated"`
      Version     int         `json:"version"`
  }
  
  func (ss *StateService) GetAllScopes() ([]string, error) {
      // Get list of all state scopes
  }
  
  func (ss *StateService) GetScopeData(scope string) ([]StateData, error) {
      // Get all key-value pairs for a scope
  }
  
  func (ss *StateService) GetStateValue(scope, key string) (*StateData, error) {
      // Get specific state value
  }
  
  func (ss *StateService) SetStateValue(scope, key string, value interface{}) error {
      // Set state value (with authentication)
  }
  
  func (ss *StateService) DeleteStateValue(scope, key string) error {
      // Delete state value (with authentication)
  }
  ```
- [ ] Implement authenticated state operations using user session tokens
- [ ] Add state browsing and editing capabilities
- [ ] Create state backup and restore functionality
- [ ] Implement state change notifications
- [ ] Add state validation and schema checking

#### State Management Features:
- **Scope Browsing**: Navigate through service scopes and data
- **Real-time Updates**: Live state changes via pub/sub
- **Edit Capabilities**: In-place editing with validation
- **Backup/Restore**: State snapshots and restoration
- **Audit Trail**: State change history and attribution

#### Acceptance Criteria:
- [ ] State data browsing works with proper authentication
- [ ] State editing respects user permissions
- [ ] Real-time updates reflect changes immediately
- [ ] Backup and restore operations work correctly
- [ ] State operations are properly audited

### 3.3 Health Check Service
**Priority**: High
**Estimated Time**: 3-4 days

#### Tasks:
- [ ] Create Health Check service in `internal/services/health_service.go`:
  ```go
  // internal/services/health_service.go
  type HealthService struct {
      brokerService *BrokerService
      stateService  *StateService
      identityClient *auth.IdentityClient
  }
  
  type SystemHealth struct {
      Overall    string               `json:"overall"` // "healthy", "degraded", "unhealthy"
      Components map[string]Component `json:"components"`
      Timestamp  time.Time           `json:"timestamp"`
      Uptime     time.Duration       `json:"uptime"`
  }
  
  type Component struct {
      Status     string            `json:"status"`
      Message    string            `json:"message"`
      Latency    time.Duration     `json:"latency"`
      LastCheck  time.Time         `json:"last_check"`
      Metadata   map[string]string `json:"metadata"`
  }
  
  func (hs *HealthService) GetSystemHealth() (*SystemHealth, error) {
      // Aggregate health from all components
  }
  
  func (hs *HealthService) CheckComponentHealth(component string) (*Component, error) {
      // Check specific component health
  }
  
  func (hs *HealthService) RunHealthCheck() (*SystemHealth, error) {
      // Execute comprehensive health check
  }
  ```
- [ ] Implement comprehensive system health aggregation
- [ ] Add individual service health checking
- [ ] Create health check scheduling and automation
- [ ] Implement health alerting and notifications
- [ ] Add health trend analysis and reporting

#### Health Check Features:
- **Comprehensive Monitoring**: All plantd services and dependencies
- **Automated Checks**: Scheduled health checks with configurable intervals
- **Alert Integration**: Health degradation notifications
- **Historical Trends**: Health status over time
- **Dependency Mapping**: Service dependency health impact

#### Acceptance Criteria:
- [ ] System health accurately reflects component status
- [ ] Individual component checks work correctly
- [ ] Health trends provide operational insights
- [ ] Alerting notifies of health degradation
- [ ] Health checks don't impact system performance

### 3.4 Configuration Management Service
**Priority**: Medium
**Estimated Time**: 4-5 days

#### Tasks:
- [ ] Create Configuration service in `internal/services/config_service.go`:
  ```go
  // internal/services/config_service.go
  type ConfigService struct {
      stateService *StateService
      broker       *BrokerService
  }
  
  type ConfigFile struct {
      Service     string            `json:"service"`
      Filename    string            `json:"filename"`
      Content     string            `json:"content"`
      Format      string            `json:"format"` // "yaml", "json", "toml"
      LastUpdated time.Time         `json:"last_updated"`
      Version     int               `json:"version"`
      Validation  ValidationResult  `json:"validation"`
  }
  
  type ValidationResult struct {
      Valid   bool     `json:"valid"`
      Errors  []string `json:"errors"`
      Warnings []string `json:"warnings"`
  }
  
  func (cs *ConfigService) GetServiceConfigs() ([]ConfigFile, error) {
      // Get configuration files for all services
  }
  
  func (cs *ConfigService) GetServiceConfig(service, filename string) (*ConfigFile, error) {
      // Get specific configuration file
  }
  
  func (cs *ConfigService) UpdateConfig(service, filename, content string) error {
      // Update configuration with validation
  }
  
  func (cs *ConfigService) ValidateConfig(service, filename, content string) (*ValidationResult, error) {
      // Validate configuration before applying
  }
  
  func (cs *ConfigService) BackupConfigs() error {
      // Create configuration backup
  }
  ```
- [ ] Implement configuration file editing with syntax highlighting
- [ ] Add configuration validation and schema checking
- [ ] Create configuration backup and versioning
- [ ] Implement configuration deployment and rollback
- [ ] Add configuration change notifications to services

#### Configuration Management Features:
- **File Editor**: Syntax-highlighted editing for YAML, JSON, TOML
- **Validation**: Real-time configuration validation
- **Version Control**: Configuration history and rollback
- **Deployment**: Safe configuration deployment with rollback
- **Schema Support**: Configuration schema validation

#### Acceptance Criteria:
- [ ] Configuration editing works with proper validation
- [ ] Configuration changes are properly versioned
- [ ] Configuration deployment doesn't break services
- [ ] Rollback functionality works correctly
- [ ] Configuration changes are properly audited

### 3.5 Metrics and Performance Service
**Priority**: Medium
**Estimated Time**: 4-5 days

#### Tasks:
- [ ] Create Metrics service in `internal/services/metrics_service.go`:
  ```go
  // internal/services/metrics_service.go
  type MetricsService struct {
      brokerService *BrokerService
      stateService  *StateService
  }
  
  type SystemMetrics struct {
      Timestamp    time.Time                  `json:"timestamp"`
      Performance  PerformanceMetrics         `json:"performance"`
      Services     map[string]ServiceMetrics  `json:"services"`
      System       SystemStats                `json:"system"`
  }
  
  type PerformanceMetrics struct {
      RequestRate    float64       `json:"request_rate"`
      ResponseTime   time.Duration `json:"response_time"`
      ErrorRate      float64       `json:"error_rate"`
      Throughput     float64       `json:"throughput"`
      ActiveSessions int           `json:"active_sessions"`
  }
  
  type ServiceMetrics struct {
      Workers     int           `json:"workers"`
      RequestRate float64       `json:"request_rate"`
      ErrorRate   float64       `json:"error_rate"`
      Latency     time.Duration `json:"latency"`
      Memory      uint64        `json:"memory"`
      CPU         float64       `json:"cpu"`
  }
  
  func (ms *MetricsService) GetSystemMetrics() (*SystemMetrics, error) {
      // Collect comprehensive system metrics
  }
  
  func (ms *MetricsService) GetServiceMetrics(service string) (*ServiceMetrics, error) {
      // Get metrics for specific service
  }
  
  func (ms *MetricsService) GetHistoricalMetrics(timeRange string) ([]*SystemMetrics, error) {
      // Get metrics over time period
  }
  ```
- [ ] Implement real-time performance monitoring
- [ ] Add historical metrics collection and storage
- [ ] Create performance alerting and thresholds
- [ ] Implement metrics visualization data
- [ ] Add system resource monitoring

#### Metrics Features:
- **Real-time Monitoring**: Live system performance metrics
- **Historical Data**: Metrics over time for trend analysis
- **Service-specific**: Individual service performance tracking
- **Resource Monitoring**: CPU, memory, network usage
- **Performance Alerts**: Threshold-based alerting

#### Acceptance Criteria:
- [ ] Metrics collection works for all services
- [ ] Historical data provides useful insights
- [ ] Performance monitoring doesn't impact system performance
- [ ] Metrics visualization data is accurate
- [ ] Alerting provides timely notifications

---

## âœ… PHASE 3 COMPLETION CRITERIA

**Status**: ðŸŸ¡ **READY FOR IMPLEMENTATION**

### Phase 3 Achievements Required:
- **Service Integration**: Complete integration with Broker, State, and Identity services
- **Health Monitoring**: Comprehensive system health checking and reporting
- **Configuration Management**: Safe configuration editing with validation and deployment
- **Metrics Collection**: Real-time and historical performance monitoring

### Ready for Phase 4:
All prerequisites met for Frontend UI Implementation:
- API services provide all required data and functionality
- Service integration works reliably with proper error handling
- Health checks provide comprehensive system status
- Configuration management supports safe operations
- Metrics services provide performance insights

---

## Phase 4: Frontend UI Implementation (4-5 weeks)

### 4.1 Administrative Dashboard Implementation
**Priority**: Critical
**Estimated Time**: 6-7 days

#### Tasks:
- [ ] Create comprehensive administrative dashboard for plantd system management
- [ ] Implement multi-level navigation structure:
  ```
  Dashboard Structure:
  â”œâ”€â”€ System Overview (Home)
  â”œâ”€â”€ Services Management
  â”‚   â”œâ”€â”€ Service Status & Control
  â”‚   â”œâ”€â”€ Service Configuration
  â”‚   â””â”€â”€ Service Dependencies
  â”œâ”€â”€ System Administration
  â”‚   â”œâ”€â”€ User Management (via Identity Service)
  â”‚   â”œâ”€â”€ Role & Permission Management
  â”‚   â”œâ”€â”€ System Configuration
  â”‚   â””â”€â”€ Backup & Restore
  â”œâ”€â”€ Monitoring & Analytics
  â”‚   â”œâ”€â”€ Health Monitoring
  â”‚   â”œâ”€â”€ Performance Metrics
  â”‚   â”œâ”€â”€ Log Aggregation
  â”‚   â””â”€â”€ Alert Configuration
  â””â”€â”€ Tools & Utilities
      â”œâ”€â”€ Diagnostic Tools
      â”œâ”€â”€ Maintenance Tasks
      â””â”€â”€ System Reports
  ```
- [ ] Create main dashboard handler with real-time system overview
- [ ] Implement dashboard templ components with responsive design
- [ ] Add Server-Sent Events for real-time administrative updates
- [ ] Create administrative-focused charts and metrics visualization
- [ ] Implement role-based dashboard customization and administrative preferences
- [ ] Add quick action panels for common administrative tasks
- [ ] Create system status overview with drill-down capabilities

#### Administrative Dashboard Features:
- **Administrative Control Center**: Central hub for all plantd system administration
- **Multi-Service Overview**: Unified view of all plantd services and their status
- **Role-Based Access**: Different dashboard views based on administrative roles
- **Quick Actions**: Fast access to common administrative operations
- **System Health Summary**: Comprehensive system health with administrative alerts
- **Performance Monitoring**: Administrative performance metrics and trends
- **Configuration Overview**: System-wide configuration status and management
- **User Activity Monitoring**: Administrative oversight of user activities
- **Maintenance Scheduling**: Administrative tools for system maintenance
- **Audit Trail**: Administrative access to system audit logs

#### Acceptance Criteria:
- [ ] Administrative dashboard provides comprehensive system oversight
- [ ] Role-based access controls show appropriate administrative functions
- [ ] Responsive design works for administrative workflows on all devices
- [ ] Real-time updates provide immediate administrative awareness
- [ ] Quick actions streamline common administrative tasks
- [ ] System overview enables effective administrative decision-making
- [ ] Dashboard performance supports administrative efficiency

### 4.2 Services Management UI
**Priority**: High
**Estimated Time**: 4-5 days

#### Tasks:
- [ ] Create services management interface with comprehensive service information
- [ ] Implement service details modal with operational insights
- [ ] Add service action buttons with proper confirmations
- [ ] Create service configuration viewing and editing
- [ ] Implement service dependency visualization

#### Services Features:
- **Service List**: Comprehensive list of all registered services
- **Status Monitoring**: Real-time status indicators with health information
- **Service Details**: Detailed view of service configuration and metrics
- **Service Actions**: Safe service management operations
- **Dependency Mapping**: Visual representation of service dependencies

### 4.3 Health Check UI
**Priority**: High
**Estimated Time**: 3-4 days

#### Tasks:
- [ ] Create comprehensive health monitoring interface
- [ ] Implement health status visualization with color coding
- [ ] Add health trend charts and historical data
- [ ] Create component-specific health details
- [ ] Implement health alerting and notification settings

### 4.4 Configuration Management UI
**Priority**: Medium
**Estimated Time**: 5-6 days

#### Tasks:
- [ ] Create configuration management interface
- [ ] Implement syntax-highlighted code editor
- [ ] Add real-time configuration validation
- [ ] Create configuration backup and restore functionality
- [ ] Implement safe configuration deployment with rollback

### 4.5 Metrics and Performance UI
**Priority**: Medium
**Estimated Time**: 5-6 days

#### Tasks:
- [ ] Create metrics dashboard with interactive charts
- [ ] Add time range selection for historical metrics
- [ ] Create service-specific performance views
- [ ] Implement metrics alerting and threshold configuration
- [ ] Add metrics export functionality

---

## Phase 5: Testing and Production Readiness (2-3 weeks)

### 5.1 Comprehensive Testing
**Priority**: Critical
**Estimated Time**: 5-6 days

#### Testing Coverage:
- **Unit Tests**: >90% coverage for services and handlers
- **Integration Tests**: Service communication and authentication
- **End-to-End Tests**: Complete user workflows
- **Performance Tests**: UI responsiveness and load times
- **Security Tests**: Authentication, authorization, and CSRF protection

### 5.2 Security Hardening
**Priority**: Critical
**Estimated Time**: 3-4 days

#### Security Features:
- **Input Validation**: All user inputs validated and sanitized
- **CSRF Protection**: Token-based protection for all forms
- **XSS Prevention**: Content Security Policy and output encoding
- **Session Security**: Secure session configuration
- **Rate Limiting**: Protection against abuse and DoS attacks

### 5.3 Performance Optimization
**Priority**: High
**Estimated Time**: 3-4 days

#### Performance Targets:
- **Page Load Time**: <2 seconds for initial load
- **API Response Time**: <500ms for most operations
- **Memory Usage**: <100MB for typical usage
- **CSS Bundle Size**: <50KB compressed

### 5.4 Documentation and Deployment
**Priority**: High
**Estimated Time**: 3-4 days

#### Documentation Requirements:
- **User Guide**: Complete interface documentation
- **Administrator Guide**: System administration and configuration
- **Developer Guide**: API documentation and integration patterns
- **Deployment Guide**: Docker, Kubernetes, and production deployment
- **Troubleshooting**: Common issues and resolution procedures

---

## Integration with Current State Matrix

Upon completion, the App Service status should be updated to:

| Service | Implementation | Testing | Documentation | Production Ready |
|---------|---------------|---------|---------------|------------------|
| **App** | âœ… Complete | âœ… Good | âœ… Complete | âœ… Production Ready |

### Areas of Improvement Identified

#### 1. Architecture Improvements
- **Service Integration Patterns**: Web-based service integration templates
- **Authentication Templates**: Web session management patterns
- **UI Component Library**: Reusable templ component patterns

#### 2. Development Process Improvements
- **Frontend Development Workflow**: Modern frontend practices with templ/bun/Tailwind
- **Testing Strategies**: Comprehensive testing including e2e testing
- **Performance Monitoring**: Real-time optimization strategies

#### 3. Operational Improvements
- **System Observability**: Comprehensive health and metrics collection
- **Configuration Management**: Safe configuration deployment procedures
- **Security Posture**: Web-based authentication and authorization

#### 4. User Experience Improvements
- **Modern Interface**: Responsive, mobile-friendly design
- **Real-time Updates**: Live system status and metrics
- **Intuitive Navigation**: User-friendly system management

This execution plan provides a complete roadmap for transforming the App Service into a production-ready, modern web application serving as the central management interface for the plantd distributed control system.

---

## Phase 4: Frontend UI Implementation (4-5 weeks)

### 4.1 Dashboard Implementation
**Priority**: Critical
**Estimated Time**: 5-6 days

#### Tasks:
- [ ] Create main dashboard handler in `internal/handlers/dashboard_handler.go`:
  ```go
  // internal/handlers/dashboard_handler.go
  type DashboardHandler struct {
      brokerService  *services.BrokerService
      healthService  *services.HealthService
      metricsService *services.MetricsService
      templates      *TemplateEngine
  }
  
  func (dh *DashboardHandler) ShowDashboard(c *gin.Context) {
      user := c.MustGet("user").(*identity.UserContext)
      
      // Collect dashboard data
      systemHealth, _ := dh.healthService.GetSystemHealth()
      serviceStatuses, _ := dh.brokerService.GetServiceStatuses()
      metrics, _ := dh.metricsService.GetSystemMetrics()
      
      data := gin.H{
          "user":            user,
          "system_health":   systemHealth,
          "services":        serviceStatuses,
          "metrics":         metrics,
          "page_title":      "Dashboard",
      }
      
      dh.templates.Render(c, "pages/dashboard", data)
  }
  ```
- [ ] Create dashboard templ component:
  ```templ
  // views/pages/dashboard.templ
  package pages
  
  import "github.com/geoffjay/plantd/app/views/layouts"
  import "github.com/geoffjay/plantd/app/views/components"
  
  templ Dashboard(data DashboardData) {
      @layouts.Dashboard("Dashboard - Plantd") {
          <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-6 mb-8">
              @components.MetricCard("Services", data.ServiceCount, "text-blue-600", "M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2")
              @components.MetricCard("Health", data.HealthStatus, "text-green-600", "M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z")
              @components.MetricCard("Requests/sec", data.RequestRate, "text-purple-600", "M13 10V3L4 14h7v7l9-11h-7z")
              @components.MetricCard("Uptime", data.Uptime, "text-indigo-600", "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z")
          </div>
          
          <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
              <div class="bg-white rounded-lg shadow p-6">
                  <h3 class="text-lg font-medium text-gray-900 mb-4">Service Status</h3>
                  @components.ServiceStatusList(data.Services)
              </div>
              
              <div class="bg-white rounded-lg shadow p-6">
                  <h3 class="text-lg font-medium text-gray-900 mb-4">System Health</h3>
                  @components.HealthStatusChart(data.HealthComponents)
              </div>
          </div>
          
          <div class="mt-8">
              <div class="bg-white rounded-lg shadow p-6">
                  <h3 class="text-lg font-medium text-gray-900 mb-4">Performance Metrics</h3>
                  @components.MetricsChart(data.PerformanceData)
              </div>
          </div>
      }
  }
  ```
- [ ] Implement real-time updates using Server-Sent Events (SSE)
- [ ] Create responsive grid layout for different screen sizes
- [ ] Add interactive charts and graphs for metrics visualization
- [ ] Implement dashboard customization and user preferences

#### Dashboard Features:
- **System Overview**: High-level system status and metrics
- **Service Status**: Real-time status of all plantd services
- **Performance Metrics**: Charts showing system performance over time
- **Health Monitoring**: Visual health indicators for all components
- **Real-time Updates**: Live updates without page refresh

#### Acceptance Criteria:
- [ ] Dashboard displays accurate real-time system information
- [ ] Responsive design works on mobile, tablet, and desktop
- [ ] Real-time updates work smoothly without impacting performance
- [ ] Charts and visualizations are clear and informative
- [ ] Dashboard loads quickly with good performance

### 4.2 Services Management UI
**Priority**: High
**Estimated Time**: 4-5 days

#### Tasks:
- [ ] Create services handler in `internal/handlers/services_handler.go`
- [ ] Create services page using templ:
  ```templ
  // views/pages/services.templ
  package pages
  
  templ Services(services []ServiceStatus) {
      @layouts.Dashboard("Services - Plantd") {
          <div class="mb-6">
              <h1 class="text-2xl font-bold text-gray-900">Services</h1>
              <p class="text-gray-600">Monitor and manage plantd services</p>
          </div>
          
          <div class="bg-white shadow rounded-lg overflow-hidden">
              <table class="min-w-full divide-y divide-gray-200">
                  <thead class="bg-gray-50">
                      <tr>
                          <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Service</th>
                          <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                          <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Workers</th>
                          <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Last Seen</th>
                          <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
                      </tr>
                  </thead>
                  <tbody class="bg-white divide-y divide-gray-200">
                      for _, service := range services {
                          @components.ServiceRow(service)
                      }
                  </tbody>
              </table>
          </div>
      }
  }
  ```
- [ ] Implement service details modal/page with comprehensive information
- [ ] Add service action buttons (restart, stop, view logs)
- [ ] Create service configuration viewing and editing
- [ ] Implement service dependency visualization

#### Services Features:
- **Service List**: Comprehensive list of all registered services
- **Status Monitoring**: Real-time status indicators with health information
- **Service Details**: Detailed view of service configuration and metrics
- **Service Actions**: Safe service management operations
- **Dependency Mapping**: Visual representation of service dependencies

#### Acceptance Criteria:
- [ ] Services list shows accurate status and information
- [ ] Service details provide comprehensive operational insights
- [ ] Service actions work safely with proper confirmations
- [ ] Service management respects user permissions
- [ ] Service dependencies are clearly visualized

### 4.3 Health Check UI
**Priority**: High
**Estimated Time**: 3-4 days

#### Tasks:
- [ ] Create health handler in `internal/handlers/health_handler.go`
- [ ] Create health check page:
  ```templ
  // views/pages/health.templ
  package pages
  
  templ Health(systemHealth SystemHealth) {
      @layouts.Dashboard("Health - Plantd") {
          <div class="mb-6">
              <h1 class="text-2xl font-bold text-gray-900">System Health</h1>
              <p class="text-gray-600">Monitor system health and component status</p>
          </div>
          
          <div class="mb-8">
              @components.SystemHealthOverview(systemHealth.Overall, systemHealth.Uptime)
          </div>
          
          <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
              for name, component := range systemHealth.Components {
                  @components.ComponentHealthCard(name, component)
              }
          </div>
          
          <div class="mt-8">
              <div class="bg-white rounded-lg shadow p-6">
                  <h3 class="text-lg font-medium text-gray-900 mb-4">Health Trends</h3>
                  @components.HealthTrendChart(systemHealth.HistoricalData)
              </div>
          </div>
      }
  }
  ```
- [ ] Implement health status visualization with color coding
- [ ] Add health trend charts and historical data
- [ ] Create component-specific health details
- [ ] Implement health alerting and notification settings

#### Health Features:
- **System Overview**: Overall system health status
- **Component Details**: Individual component health information
- **Historical Trends**: Health status over time
- **Alert Configuration**: Health threshold and notification settings
- **Diagnostic Tools**: Health check execution and troubleshooting

#### Acceptance Criteria:
- [ ] Health status accurately reflects system state
- [ ] Health visualization is clear and informative
- [ ] Historical data provides useful insights
- [ ] Health alerts work correctly
- [ ] Diagnostic tools help with troubleshooting

### 4.4 Configuration Management UI
**Priority**: Medium
**Estimated Time**: 5-6 days

#### Tasks:
- [ ] Create configuration handler in `internal/handlers/config_handler.go`
- [ ] Create configuration management page:
  ```templ
  // views/pages/config.templ
  package pages
  
  templ Config(configs []ConfigFile) {
      @layouts.Dashboard("Configuration - Plantd") {
          <div class="mb-6 flex justify-between items-center">
              <div>
                  <h1 class="text-2xl font-bold text-gray-900">Configuration</h1>
                  <p class="text-gray-600">Manage service configurations</p>
              </div>
              <button class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700">
                  Backup Configurations
              </button>
          </div>
          
          <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
              <div class="lg:col-span-1">
                  <div class="bg-white rounded-lg shadow">
                      <div class="px-4 py-5 sm:p-6">
                          <h3 class="text-lg font-medium text-gray-900 mb-4">Services</h3>
                          @components.ConfigServiceList(configs)
                      </div>
                  </div>
              </div>
              
              <div class="lg:col-span-2">
                  <div class="bg-white rounded-lg shadow">
                      <div class="px-4 py-5 sm:p-6">
                          <div class="flex justify-between items-center mb-4">
                              <h3 class="text-lg font-medium text-gray-900">Configuration Editor</h3>
                              <div class="flex space-x-2">
                                  <button class="bg-green-600 text-white px-3 py-1 text-sm rounded hover:bg-green-700">
                                      Validate
                                  </button>
                                  <button class="bg-blue-600 text-white px-3 py-1 text-sm rounded hover:bg-blue-700">
                                      Save
                                  </button>
                              </div>
                          </div>
                          @components.ConfigEditor()
                      </div>
                  </div>
              </div>
          </div>
      }
  }
  ```
- [ ] Implement syntax-highlighted code editor for configuration files
- [ ] Add real-time configuration validation
- [ ] Create configuration backup and restore functionality
- [ ] Implement configuration deployment with rollback
- [ ] Add configuration history and versioning

#### Configuration Features:
- **File Browser**: Navigate through service configuration files
- **Code Editor**: Syntax-highlighted editing with validation
- **Version Control**: Configuration history and rollback capabilities
- **Validation**: Real-time configuration validation and error reporting
- **Safe Deployment**: Configuration deployment with rollback capabilities

#### Acceptance Criteria:
- [ ] Configuration editor provides good development experience
- [ ] Configuration validation prevents invalid deployments
- [ ] Configuration versioning works correctly
- [ ] Configuration deployment is safe and reliable
- [ ] Rollback functionality works when needed

### 4.5 Metrics and Performance UI
**Priority**: Medium
**Estimated Time**: 5-6 days

#### Tasks:
- [ ] Create metrics handler in `internal/handlers/metrics_handler.go`
- [ ] Create metrics page with charts and visualizations:
  ```templ
  // views/pages/metrics.templ
  package pages
  
  templ Metrics(metrics SystemMetrics) {
      @layouts.Dashboard("Metrics - Plantd") {
          <div class="mb-6">
              <h1 class="text-2xl font-bold text-gray-900">Performance Metrics</h1>
              <p class="text-gray-600">Monitor system performance and resource usage</p>
          </div>
          
          <div class="grid grid-cols-1 xl:grid-cols-2 gap-6 mb-8">
              <div class="bg-white rounded-lg shadow p-6">
                  <h3 class="text-lg font-medium text-gray-900 mb-4">Request Rate</h3>
                  @components.RequestRateChart(metrics.Performance.RequestRate)
              </div>
              
              <div class="bg-white rounded-lg shadow p-6">
                  <h3 class="text-lg font-medium text-gray-900 mb-4">Response Time</h3>
                  @components.ResponseTimeChart(metrics.Performance.ResponseTime)
              </div>
              
              <div class="bg-white rounded-lg shadow p-6">
                  <h3 class="text-lg font-medium text-gray-900 mb-4">Error Rate</h3>
                  @components.ErrorRateChart(metrics.Performance.ErrorRate)
              </div>
              
              <div class="bg-white rounded-lg shadow p-6">
                  <h3 class="text-lg font-medium text-gray-900 mb-4">Resource Usage</h3>
                  @components.ResourceUsageChart(metrics.System)
              </div>
          </div>
          
          <div class="bg-white rounded-lg shadow p-6">
              <h3 class="text-lg font-medium text-gray-900 mb-4">Service Performance</h3>
              @components.ServicePerformanceTable(metrics.Services)
          </div>
      }
  }
  ```
- [ ] Implement interactive charts using Chart.js or similar
- [ ] Add time range selection for historical metrics
- [ ] Create service-specific performance views
- [ ] Implement metrics alerting and threshold configuration
- [ ] Add metrics export functionality

#### Metrics Features:
- **Performance Charts**: Interactive charts for key performance indicators
- **Historical Data**: Time-series data with configurable time ranges
- **Service Breakdown**: Per-service performance metrics
- **Resource Monitoring**: System resource usage tracking
- **Alert Configuration**: Performance threshold alerting

#### Acceptance Criteria:
- [ ] Metrics charts are interactive and informative
- [ ] Historical data provides useful performance insights
- [ ] Service-specific metrics help with optimization
- [ ] Resource monitoring provides operational awareness
- [ ] Metrics export works for external analysis

---

## âœ… PHASE 4 COMPLETION CRITERIA

**Status**: ðŸŸ¡ **READY FOR IMPLEMENTATION**

### Phase 4 Achievements Required:
- **Complete UI**: Comprehensive web interface for all plantd management functions
- **Dashboard**: Real-time system overview with metrics and status
- **Service Management**: Complete service monitoring and management interface
- **Health Monitoring**: Visual health status and trend analysis
- **Configuration**: Safe configuration editing with validation and deployment
- **Metrics**: Performance monitoring with historical data and alerting

### Ready for Phase 5:
All prerequisites met for Testing and Production Readiness:
- Complete user interface provides all required functionality
- All features work correctly with proper error handling
- User experience is intuitive and responsive
- Performance is acceptable for production use

---

## Phase 5: Testing and Production Readiness (2-3 weeks)

### 5.1 Comprehensive Testing
**Priority**: Critical
**Estimated Time**: 5-6 days

#### Tasks:
- [ ] Create unit tests for all services and handlers
- [ ] Implement integration tests for service communication
- [ ] Add end-to-end tests for complete user workflows
- [ ] Create performance tests for UI responsiveness
- [ ] Implement security tests for authentication and authorization

#### Testing Coverage:
- **Unit Tests**: >90% coverage for services and handlers
- **Integration Tests**: Service communication and authentication
- **End-to-End Tests**: Complete user workflows from login to management
- **Performance Tests**: Page load times and responsiveness
- **Security Tests**: Authentication, authorization, and CSRF protection

#### Acceptance Criteria:
- [ ] Test coverage meets >90% for critical components
- [ ] All user workflows are thoroughly tested
- [ ] Performance tests validate acceptable response times
- [ ] Security tests validate protection mechanisms
- [ ] CI/CD pipeline includes automated testing

### 5.2 Security Hardening
**Priority**: Critical
**Estimated Time**: 3-4 days

#### Tasks:
- [ ] Implement comprehensive input validation and sanitization
- [ ] Add Content Security Policy (CSP) headers
- [ ] Implement rate limiting for all endpoints
- [ ] Add security headers (HSTS, X-Frame-Options, etc.)
- [ ] Conduct security audit and penetration testing

#### Security Features:
- **Input Validation**: All user inputs validated and sanitized
- **CSRF Protection**: Token-based CSRF protection for all forms
- **XSS Prevention**: Content Security Policy and output encoding
- **Session Security**: Secure session configuration and management
- **Rate Limiting**: Protection against abuse and DoS attacks

#### Acceptance Criteria:
- [ ] Security audit passes with no critical vulnerabilities
- [ ] CSRF protection works for all state-changing operations
- [ ] XSS protection prevents script injection
- [ ] Rate limiting protects against abuse
- [ ] Security headers provide comprehensive protection

### 5.3 Performance Optimization
**Priority**: High
**Estimated Time**: 3-4 days

#### Tasks:
- [ ] Optimize CSS and JavaScript assets
- [ ] Implement caching strategies for API responses
- [ ] Add compression for static assets
- [ ] Optimize database queries and service calls
- [ ] Implement lazy loading for large datasets

#### Performance Targets:
- **Page Load Time**: <2 seconds for initial load
- **Time to Interactive**: <3 seconds for full functionality
- **API Response Time**: <500ms for most operations
- **Memory Usage**: <100MB for typical usage
- **CSS Bundle Size**: <50KB compressed

#### Acceptance Criteria:
- [ ] Page load times meet performance targets
- [ ] API responses are fast and efficient
- [ ] Memory usage is reasonable for production
- [ ] Asset sizes are optimized for delivery
- [ ] Performance monitoring is in place

### 5.4 Documentation and Deployment
**Priority**: High
**Estimated Time**: 3-4 days

#### Tasks:
- [ ] Create comprehensive user documentation
- [ ] Write deployment and configuration guides
- [ ] Create troubleshooting and maintenance documentation
- [ ] Implement Docker and Kubernetes deployment configurations
- [ ] Create monitoring and alerting setup guides

#### Documentation Requirements:
- **User Guide**: Complete user interface documentation
- **Administrator Guide**: System administration and configuration
- **Developer Guide**: API documentation and integration patterns
- **Deployment Guide**: Docker, Kubernetes, and production deployment
- **Troubleshooting**: Common issues and resolution procedures

#### Acceptance Criteria:
- [ ] Documentation is comprehensive and accurate
- [ ] Deployment procedures are tested and validated
- [ ] Monitoring and alerting are properly configured
- [ ] Troubleshooting guides help resolve common issues
- [ ] Documentation enables self-service adoption

---

## âœ… PHASE 5 COMPLETION CRITERIA

**Status**: ðŸŸ¡ **READY FOR IMPLEMENTATION**

### Phase 5 Achievements Required:
- **Comprehensive Testing**: Complete test coverage with automated testing
- **Security Hardening**: Production-ready security with audit validation
- **Performance Optimization**: Fast, responsive user interface
- **Production Deployment**: Complete deployment procedures and documentation

### Production Ready:
All requirements met for production deployment:
- Security audit passes with comprehensive protection
- Performance meets production targets
- Testing validates all functionality works correctly
- Documentation enables operational support and maintenance

---

## Phase 6: Extended Administrative Features (1-2 weeks) [Optional Enhancement]

### 6.1 Iframe Integration Framework
**Priority**: Low (Future Enhancement)
**Estimated Time**: 4-5 days

#### Purpose:
Enable other plantd services to contribute user interface elements by embedding their web interfaces as secure iframes within the App Service dashboard. This provides a plugin-like architecture for extending the administrative interface.

#### Tasks:
- [ ] Design iframe integration architecture with security considerations
- [ ] Create iframe management service in `internal/services/iframe_service.go`:
  ```go
  // internal/services/iframe_service.go
  type IframeService struct {
      config         *config.Config
      identityClient *auth.IdentityClient
      registeredFrames map[string]IframeConfig
  }
  
  type IframeConfig struct {
      ServiceName string            `json:"service_name"`
      Title       string            `json:"title"`
      URL         string            `json:"url"`
      Permissions []string          `json:"permissions"`
      Category    string            `json:"category"` // "monitoring", "configuration", "tools"
      Icon        string            `json:"icon"`
      Sandbox     []string          `json:"sandbox"` // iframe sandbox attributes
      Headers     map[string]string `json:"headers"`  // CSP and security headers
  }
  
  func (is *IframeService) RegisterIframe(config IframeConfig) error {
      // Register iframe with security validation
  }
  
  func (is *IframeService) GetAuthorizedIframes(userContext *identity.UserContext) ([]IframeConfig, error) {
      // Return iframes user has permissions to access
  }
  
  func (is *IframeService) ValidateIframeRequest(serviceURL string, userToken string) error {
      // Validate iframe request and pass authentication context
  }
  ```
- [ ] Implement secure iframe authentication token passing
- [ ] Create iframe container templ component:
  ```templ
  // views/components/iframe_container.templ
  package components
  
  templ IframeContainer(iframe IframeConfig, authToken string) {
      <div class="iframe-container bg-white rounded-lg shadow overflow-hidden">
          <div class="iframe-header bg-gray-50 px-4 py-3 border-b border-gray-200">
              <div class="flex items-center">
                  if iframe.Icon != "" {
                      <img src={ iframe.Icon } alt={ iframe.ServiceName } class="h-5 w-5 mr-2"/>
                  }
                  <h3 class="text-lg font-medium text-gray-900">{ iframe.Title }</h3>
                  <span class="ml-2 text-sm text-gray-500">({ iframe.ServiceName })</span>
              </div>
          </div>
          <div class="iframe-content">
              <iframe 
                  src={ iframe.URL + "?token=" + authToken }
                  sandbox="allow-scripts allow-same-origin allow-forms allow-popups"
                  class="w-full h-96 border-0"
                  security="restricted"
                  referrerpolicy="strict-origin-when-cross-origin">
              </iframe>
          </div>
      </div>
  }
  ```
- [ ] Add iframe management API endpoints
- [ ] Implement iframe security policies and sandboxing
- [ ] Create iframe configuration management interface

#### Iframe Integration Features:
- **Service Registration**: Services can register their web UI components
- **Security Sandbox**: Secure iframe isolation with CSP and sandbox attributes
- **Authentication Propagation**: Secure token passing to embedded services
- **Permission-Based Access**: Role-based iframe visibility and access control
- **Dynamic Loading**: Runtime iframe registration and management
- **Category Organization**: Logical grouping of iframe content
- **Responsive Design**: Iframe containers adapt to different screen sizes

#### Security Considerations:
- **Content Security Policy**: Strict CSP headers for iframe content
- **Sandbox Attributes**: Limited iframe capabilities (scripts, forms, same-origin)
- **Token Validation**: Secure authentication token passing and validation
- **Origin Validation**: Whitelist of allowed iframe source origins
- **HTTPS Only**: All iframe content must be served over HTTPS
- **Rate Limiting**: Protection against iframe abuse

#### Configuration Example:
```yaml
# config.yml iframe configuration
iframe:
  enabled: true
  max_iframes: 10
  allowed_origins:
    - "https://metrics.plantd.local"
    - "https://logs.plantd.local"
    - "https://monitoring.plantd.local"
  security:
    enforce_https: true
    token_expiry: "1h"
    csp_policy: "default-src 'self'; frame-src 'self' https://*.plantd.local"
```

#### Acceptance Criteria:
- [ ] Services can register iframe components securely
- [ ] Iframe authentication works with user sessions
- [ ] Security policies prevent iframe-based attacks
- [ ] Iframe management interface allows administrative control
- [ ] Performance impact is minimal with multiple iframes
- [ ] Iframe content is properly isolated and sandboxed

### 6.2 Plugin Architecture Foundation
**Priority**: Low (Future Enhancement)
**Estimated Time**: 2-3 days

#### Tasks:
- [ ] Design plugin registration API for future service integrations
- [ ] Create plugin metadata management system
- [ ] Implement plugin lifecycle management (register, enable, disable)
- [ ] Add plugin dependency resolution
- [ ] Create plugin development documentation and examples

#### Plugin Features:
- **Plugin Discovery**: Automatic discovery of available service plugins
- **Lifecycle Management**: Enable, disable, and update plugins
- **Dependency Resolution**: Handle plugin dependencies and conflicts
- **Configuration Management**: Plugin-specific configuration handling
- **Documentation**: Developer guides for creating App Service plugins

#### Acceptance Criteria:
- [ ] Plugin architecture supports future extensibility
- [ ] Plugin registration and management works correctly
- [ ] Documentation enables third-party plugin development
- [ ] Plugin system is secure and performant
- [ ] Plugin lifecycle management prevents system instability

---

## âœ… PHASE 6 COMPLETION CRITERIA

**Status**: ðŸŸ¡ **OPTIONAL ENHANCEMENT**

### Phase 6 Achievements (Optional):
- **Iframe Integration**: Secure iframe embedding for service UI components
- **Plugin Architecture**: Foundation for extending App Service functionality
- **Security Framework**: Comprehensive security for embedded content
- **Management Interface**: Administrative control over iframe and plugin systems

### Future Enhancement Value:
Phase 6 provides the foundation for:
- **Service UI Extensions**: Services can contribute specialized UI components
- **Modular Architecture**: Plugin-based system extensibility
- **Third-party Integration**: External service integration capabilities
- **Administrative Flexibility**: Customizable dashboard with service-specific tools

---

## Integration with Current State Matrix

Upon completion of this execution plan, the App Service status in the Service Maturity Matrix should be updated to:

| Service | Implementation | Testing | Documentation | Production Ready |
|---------|---------------|---------|---------------|------------------|
| **App** | âœ… Complete | âœ… Good | âœ… Complete | âœ… Production Ready |

### Areas of Improvement Identified

During the analysis and execution planning, several areas for improvement were identified:

#### 1. Architecture Improvements
- **Administrative Dashboard Architecture**: Comprehensive multi-level administrative interface for complete plantd system management
- **Service Integration Patterns**: The App Service will establish patterns for web-based service integration that can be applied to other services
- **Authentication Templates**: Web session management patterns will complement existing CLI authentication
- **UI Component Library**: Templ component library will provide reusable patterns for future web interfaces
- **Iframe Integration Framework**: Plugin-like architecture enabling services to contribute UI components securely
- **Modular Plugin System**: Foundation for extending App Service functionality with third-party components

#### 2. Development Process Improvements
- **Frontend Development Workflow**: Integration of templ, bun, and Tailwind CSS establishes modern frontend development practices
- **Administrative Tooling**: Comprehensive administrative tools and workflows for system management
- **Testing Strategies**: Comprehensive testing approach including unit, integration, and end-to-end testing
- **Performance Monitoring**: Real-time performance monitoring and optimization strategies
- **Security Framework**: Enhanced security for embedded content and iframe integration

#### 3. Operational Improvements
- **Centralized Administration**: Single interface for managing entire plantd ecosystem
- **System Observability**: Comprehensive health monitoring and metrics collection with administrative oversight
- **Configuration Management**: Safe configuration editing and deployment procedures with administrative controls
- **Security Posture**: Web-based authentication and authorization patterns with administrative audit trails
- **Multi-Service Coordination**: Administrative tools for coordinating multiple plantd services
- **Extensible UI Framework**: Platform for services to provide specialized administrative interfaces

#### 4. User Experience Improvements
- **Administrative Control Center**: Comprehensive administrative dashboard with role-based access and quick actions
- **Modern Interface**: Responsive, mobile-friendly web interface optimized for administrative workflows
- **Real-time Updates**: Live system status and metrics with administrative alerts and notifications
- **Intuitive Navigation**: User-friendly interface for complex system management with administrative context
- **Service UI Integration**: Seamless integration of service-specific UI components within unified interface
- **Customizable Dashboard**: Administrative dashboard customization based on user roles and preferences

### Next Steps After Completion

This App Service implementation will serve as the foundation for:

1. **Administrative Control Center**: Comprehensive administrative dashboard for complete plantd system management
2. **Web Interface Patterns**: Templates for other plantd web interfaces and administrative tools
3. **Dashboard Templates**: Reusable dashboard components and administrative patterns
4. **Centralized Service Management**: Unified management interface for all plantd services with administrative oversight
5. **Monitoring Platform**: Foundation for comprehensive system monitoring with administrative alerting
6. **Configuration Hub**: Central configuration management for the entire system with administrative controls
7. **Extensible UI Platform**: Framework for services to contribute specialized administrative interfaces
8. **Plugin Ecosystem**: Foundation for third-party administrative tools and integrations

The App Service will become the **primary administrative interface** for plantd system administration, providing a modern, secure, and comprehensive management platform for the distributed control system. With the iframe integration framework (Phase 6), it will also serve as an extensible platform that allows individual services to contribute specialized UI components while maintaining centralized authentication and security.

This execution plan provides a complete roadmap for transforming the App Service from a basic framework into a **production-ready, administrative-focused web application** that serves as the central management and extensible UI platform for the plantd ecosystem. 
